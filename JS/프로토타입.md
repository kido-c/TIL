# 자바스크립트는 왜 프로토타입?

클래스가 아닌 왜 프로토타입으로 이루어져 있는가?

그렇다면 클래스틑 어떻게 동작하는가?

프로토타입과 클래스는 둘다 객체의 상속을 구현하는 방법들이다.

클래스는 객체의 상속을 어떻게 구현하는가?

### 클래스 기반의 OOP

클래스의 기원에 대해서 알아보자.
서양철학은 다음과 같은 이분법적 세계관을 가지고 있음.

- 영혼/육체
- 추상적/구체적
- 이데아/프랙티스

눈앞에 실제로, 구체적으로 존재하는 사물이 있다면 그 반대편에는 그것의 본질이 존재한다는 것

단적인 예로 의자를 들어보면, 의자는 여러가지 형태로 존재할 수 있다.
바퀴가 달린 의자, 목받침이 있는 의자, 원목 의자 등등 실제로 존재하는 의자와 `의자`라는 추상적이고 본질적인 것이 존재한다.
앞서 설명한 구제척인 의자들은 본질 세계에 있는 `의자`를 모방한 것에 불과하다는 것임을 이데아 이론은 주장한다.

이러한 사고 방식이 프로그래밍언어에 자연스럽게 녹아들어 생겨난 언어가 클래스 기반의 객체지향 프로그래밍언어 입니다.
대표적으로 Java, C#이 있다.

ex)

```java

// 본질 세계에 있는 추상적인 의자
class Chair{
    ...
}

// 실제 세계에 있는 구체적인 의자
// 인스턴스화 ( 구체적인 존재로 만드는 )
Chair myChair = new Chair()
```

이러한 이데아 이론은 분류라는 개념으로 정립됩니다.
classification -> class, class라는 키워드가 어디서 나온지 알 수 있는 부분입니다.

분류의 정의 : 개체의 속성이 동일한 경우 개체 그룹이 같은 범주에 속한다. 범주는 정의와 구별의 합이다.

- 속성 - property

### 프로토타입 기반의 OOP

프로토타입의 개념은 classification을 반박하여 나온 이론이다.

> 공유 속성의 관점에서 정의하기 어려운 개념이 있다. 사실상 올바른 분류란 없다 - 비트겐슈타인

class 개념에서 게임을 정의하면 승리와 패배라는 속성이 존재한다.
하지만 승리와 패배가 없는 게임도 있다.
-> 완전한 게임이라는 분류를 하기 위해서 속성을 정의하기 어려울 수 있다.

- JAVA로 개발하면 이와 같은 class 설계를 해야할 때가 많은데 다음과 같은 어려움이 있다.
  - 속성으로 분류하는 것은 확장성을 고려하면 좋은 방식이 아니다.
  - 정답이라고 생각했던 class 설계도 개발을 진행하면서 엎어질 수 도 있다. -> 이는 기술 부채로 이어질 수 있다.
  - 도메인 기반 설계, SOLID, 디자인 패턴등을 활용하여 개선할 수 잇다.

#### 프로토타입은 의미사용이론을 따른다.

의미사용이론은 `사용`에 의해 의미가 결정된다는 이론이다.
단어는 진정한 본래의 의미가 존재한다고 생각하는 이데아 이론에 상반되는
단어의 의미는 상황과 맥락에 의해서 결정된다고 생각하는 이론이다.

ex)

벽돌!

- 벽돌을 주세요 ( 벽돌이 필요할 때 )
- 벽돌을 채우세요 ( 벽돌로 보수해야 할 때 )
- 벽돌을 피하세요 ( 벽돌이 떨어질 때 )

즉, 말할 때 맥락이 중요하다. 벽돌이라는 본질은 중요하지 않는것 같다. ( 나의 의견 )

#### 가족 유사성

모든 가족이 공유하는 공통적인 속성은 존재하지 않는다.  
그래서 우리는 가족 유사성에 의한 분류로 서로를 구분한다.

![alt text](image-1.png)

이 이론이 프로토타입이론의 근거가 된다.

#### 프로토타입이론

객체는 정의로 분류되는 것이 아닌,
프로토타입(원형)은 가장 전형적인 것을 대표하는것

- 참새 : 프로토타입 (원형)
- 타조 : 가장 비전형적인 것

같은 단어라고 할징라도 누가 어떤 상황(컨택스트)에서 접했는지에 따라 그 의미가 달라질 수 있다.

- 아이 : 참새, 펭귄은 동일한 범주가 아닐 수 있다.
- 조류학자 : 참새와 펭귄은 동일한 범주

#### 프로토타입기반의 객체지향 프로그래밍

[특징]

- 개별 객체 수준에서 메소드와 변수를 추가
- 객체 생성은 일반적으로 복사를 통해 이루어짐
- 확장은 클래스가 아니라 위임
- 개별 객체 수준에서 객체를 수정하고 발전시키는 능력은 선험적 분류의 필요성을 줄이고 반복적인 프로그래밍 및 디자인 스타일을 장려 -> 무슨말인지?
- 프로토타입 프로그래밍은 일반적으로 분류하지 않고 유사성을 활용하도록 선택
- 결과적으로 설계는 맥락에 의해 평가
  - 실행 컨택스트, 스코프 체인이 여기서 파생
  - closure, this, 호이스팅 등등은 프로토타입의 맥락을 표현하지 위한 것

```js
function 참새() {
  this.날개갯수 = 2;
  this.날수있나 = true;
}

const 참새1 = new 참새();

console.log("참새 날개 갯수 : ", 참새1.날개갯수); // 2

function 닭() {
  this.벼슬 = true;
}

닭.prototype = 참새1; // 인스터스를 프로토타입으로 할당, 프로토타입 이론은 이미 존재하는 사물을 통해 범주화한다.
const 닭1 = new 닭();

console.log("닭1 날개 : ", 닭1.날개갯수, "날수있나?", 닭1.날수있나); // 2, true

닭1.날수있나 = false;
console.log("닭1은 날 수 있나요?", 닭1.날수있나); // false

// 여기서 참새1의 날수있나 속성은 변경되지 않는다.
// 같은 속성을 변경해도 프로토타입 객체의 속성은 변경되지 않는다.

---// 고전적인 방식의 프로토타입 연결

function 펭귄(){
    참새.call(this) // 속성을 복사
}

펭귄.prototype = Object.create(참새.prototype) // 프로토타입 연결

const 펭귄1 = new 펭귄();
console.log("펭귄1 날개 : ", 펭귄1.날개갯수, ", 날수있나? ", 펭귄1.날수있나); // 2, true
펭귄1.날수있나 = false;
console.log("다시 물어본다. 펭귄1은 날 수 있나? :", 펭귄1.날수있나); // false

```

#### lexical scope

의미사용이론에 따르면 단어의 의미는 그 어휘적인, 근처 환경에서의 의미가 된다.
변수의 의미는 그 어휘적인, 실행문맥에서의 의미가 된다.

자바스크립트 엔진은 코드가 로드될 때 실행 컨텍스트를 생성하고 그안에 선언된 변수, 함수를 실행 컨텍스트 최상당으로 호이스팅한다.
이 범위를 렉시컬 스코프라고 한다. (전역 렉시컬 스코프)

```js
// 전역 실행 컨텍스트 생성, name, init 호이스팅
var name = "kido";

// init 실행 컨텍스트 생성, name, displayName 호이스팅
init();

function init() {
  var name = "steve";
  function displayName() {
    // displayName 실행 컨텍스트 내부에 정의된 name 없음
    // scope chain으로 상위 스코프 탐색
    console.log(name); // steve
  }

  // displayName 실행 컨텍스트 생성
  displayName();
}
```

> - Global Execution // 1
> - Lexical : name, init
> - Execution : init // 2
> - Lexical : name, displayName
> - Outer : global
> - Execution : displayName // 3
> - Lexical : null
> - Outer : init

#### javascript this

앞서의 벽돌 예시에서 벽돌의 의미는 벽돌을 소리칠 때의 상황에 따라 달라진다.
의미사용이론에서는 이를 '발화'가 어디에서 되었을 때에 따라 단어의 의미가 달라진다고 말한다.

미리 분류하고 정의하고 있는 클래스와 달리 프로토타입에서는 받아들이는 주체와 문맥이 가장 중요하다.

프로그래밍관점에서 보면, 실행(invoke)하는 객체가 중요하다.

```js
var someValue = "hello";

function outerFunc() {
  console.log(this.someValue); // 첫번째 : world , 두번째 : hello
  this.innerFunc();
}

const obj = {
  someValue: "world",
  outerFunc,
  innerFunc: function () {
    console.log("innerFunc's this : ", this); // 첫번째 : obj , 두번째 : 함수 없어서 호출 안됨.
  },
};

obj.outerFunc(); // 첫번째
outerFunc(); // 두번째
```
